# RUST - MEMO

Il s'agit d'un m√©mo des concepts clefs de Rust, issu de la lecture de https://doc.rust-lang.org/book/second-edition/index.html .

## Commencer rapidement Rust

### installation

Sur Mac & linux :

```sh
curl https://sh.rustup.rs -sSf | sh
```

Si l'installation s'est bien d√©roul√©e, taper *rustup* dans le terminal doit afficher les commandes disponibles.

| Commande | description |
|---------|-------------|
|rustup update| update rustup|
|rustc --version | display Rust version |
| rustup doc | open local doc |

### Hello world

```rust
// filname: main.rs
fn main() {
    println!("Hello, world!");
}
```

> üí°La fonction *main* est sp√©ciale : c'est toujours la premi√®re partie du code ex√©cut√©e par un programme Rust.
> ‚ö†Ô∏è println! n'est **pas** une fonction mais une **macro** :  d'o√π la pr√©sence du "!" √† la fin.

Compiler puis ex√©cuter notre code.
```sh
rustc main.rs
./main
```

### üí°d√©boguer les variables avec les placeholders de "println!"

```rust
let array = [1, 2, 3];

println!("this is my variable : {:?}", array);
// affiche: "this is my variable : [1, 2, 3]"

println!("this is my variable : {:#?}", array);
// affiche :
// this is my variable : [
//    1,
//    2,
//    3
// ]
```

### Gestion des paquets

#### Cargo

**Cargo** est le system de build et le gestionnaire de paquet de Rust. Il est install√© par d√©faut avec Rust.

Voici comment cr√©er un projet avec cargo, dont le nom serait : "hello_cargo" :

```sh
cargo new hello_cargo --bin
```

> üí°l'argument --bin permet de cr√©er une application √©xecutable au lieu d'un librairie.

En Rust, les paquets sont nomm√©s **crates** : caisses / cageots.

| command | description |
|---------|-------------|
|cargo build|compiler. le binaire sera cr√©e dans "target/debug/hello_cargo"|
|cargo run|compile and ex√©cute|
|cargo check|v√©rifie les erreurs mais ne produit pas un ex√©cutable (plus rapide que "cargo run" donc)|
|cargo build --release| compiler avec optimisations. L'√©x√©cutable sera cr√©e dans "target/release" √† la pkace de "target/debug"|
|cargo update| mettre √† jour les *crates* - seulement le dernier num√©ro number de leur versionning s√©mantique|

#### Installation d'un crate

Exemple avec l'installation du crate *rand* (g√©n√©ration de nombres au hasard) : Il faut ajouter la d√©pendance au fichier *Cargo.toml*

```toml
[dependencies]
rand = "0.3.14"
```
puis taper la commande suivant √† la racine du projet :
```sh
cargo build
```

Pour pouvoir appeler les m√©thodes de "Rng", doit ajouter le *trait* √† notre scope :
```rust
extern crate rand;
// put Rng trait in the scope to use its methods like "gen_range"
use rand::Rng;
```

> üí° Pour savoir comment importer les m√©thodes et fonction d'un crate, il faut ouvir la documentation et cliquer sur le paquet concern√© dans la barre de gauche.

```sh
cargo doc --open
```

## Concepts g√©n√©raux

### Variables et mutabilit√©

#### Immutabilit√©

> üí° Rust utilise le type de casse **snake_case** pour nommer les fonctions et variables. Exemple : "hello_world()"

> ‚ö†Ô∏è Par d√©faut, les variables sont **immutables**. Le code suivant provoquera donc une erreur du compilateur.

```rust
fn main() {
    let x = 5;
    x = 6;
}
```

Il faut utiliser le mot-clef **mut** pour render une variable mutable.

```rust
fn main() {
    let mut x = 5;
    x = 6;
}
```

#### Exemples de d√©claration de variables

```rust
// d√©clarer un nombre immutable ave le type par d√©faut qui est i32 ( 32 bits sign√©s) 
let a = 42

// d√©clarer un nombre immubtale en le typant manuellement en 64 bits sign√©s.
let x: i64 = 42;

// d√©clarer un nombre
let mut y = 27;

// cr√©er une string de taille fixe et immutable (appel√©e "slice", son  type est *&str*)
let greeting = "Hello there.";

// d√©clarer une cha√Æne de caract√®res UTF-8 mutable et agrandissable ( type **String** )
let mut s = String::from("Hello");
s.push_str(", world.");
println!("{}", s); // display "Hello, world."
```

Il est possible de "shadow" une variable en r√©-utilisant le mot clef let.

```rust
let my_var = 5;
let my_var = 6;
```

### Les types de donn√©es

Il existe quatre types scalaires de donn√©es. Un type scalaire repr√©sente une donn√©es "atomique" par opposition √† des types compos√©s - comme des types listant plusieurs valeurs tels que *array*, *tuple* ou *String* (une String est une liste de *characters* )

- integers
- floating-point numbers
- Booleans
- characters

> üí° Note : ces types de donn√©es scalaires sont stock√©s uniquement dans la pile et supprimer de la pile lorsqu'il sont hors de port√©e. ( plus de d√©tails plus bas concernant la *pile* et le *tas*)

#### Le type entier

example :
```rust
let x = 142; // sera du type "entier 32 bits" par d√©fault
let y: u8 = 142;  // type entier non-sign√© 8 bits
```

|longueur|  sign√© | non-sign√© |
|--------|--------|----------|
|8-bits  | i8     | u8       |
|16-bits | i16    | u16      |
|32-bits | i32    | u32      |
|64-bits | i64    | u64      |
|arch    | isize  | usize    |


> üí° isize et usize d√©pendent du type d'ordinateur sur lequel tourne le programme : 64 bits si vous √™tes sur une architecture 64 bits, 32 bits si vous √™tes sur une architecture 32 bits.

> üí° Les entiers sont par d√©fault du type i32 parce que c'est g√©n√©ralement le type le plus performant.


#### Type nombre √† virgule flottante

exemple :
```rust
let x = 2.0; // f64 par d√©fault
let y: f32 = 142.567890; // flottant 32 bits
```

|longueur|notation|
|--------|--------|
|32-bits | f32    |
|64-bits | f64    |

> üí° Le type par d√©faut est *f64* parce que sur les CPUs moderne, il est quasimenet aussi rapidement que *f32* mais offre bien plus de pr√©cisions.

#### Le type bool√©en

```rust
let x = true;
let y: bool = false; // avec un type explicite
```

#### Le type caract√®re

```rust
let c = 'z';
let z = '‚Ñ§';
let heart_eyed_cat = 'üòª';
```

> ‚ö†Ô∏è Le type caract√®re est sp√©cifi√© avec des guillemets simples tandis que les cha√Æne de caract√®res sont sp√©cifi√©es avec des guillemets doubles.

#### Les types compos√©s

Les types compos√©s peuvent regrouper plusieurs valeurs dans un seul type. Rust propose deux types compos√©s primitifs : les **tuples** et les **arrays**.

##### Le type tuple

```rust
// cr√©er un tuple compos√© de diff√©rents types simples
let tup: (i32, f64, u8) = (500, 6.4, 1);

// lire les valeurs du tuple
let (x, y, z) = tup;

println!("The value of y is: {}", y); // affiche 6.4
println!("{}", tup.1); // affiche aussi 6.4
```
##### Le type array

Unlike a tuple, every element of an array must have the same type.

Contrairement au *tuple*, chaque √©l√©ment d'un *array* **doit √™tre du m√™me type**.

```rust
let a = [1, 2, 3, 4, 5];
// acc√©d√©rer √† la premi√®re et √† la deuxi√®me valeur du tableau.
let first = a[0];
let second = a[1];
```
> ‚ö†Ô∏è **les arrays ont une longueur fixe !**: une fois d√©clar√©, leur taille ne peut pas s'agrandir ou se r√©duire. On verra plus tard le type **vectors** dont la taille peut varier dynamiquement.

#### Op√©rations arithm√©tiques

```rust
// addition
let sum = 5 + 10;

// soustraction
let difference = 95.5 - 4.3;

// multiplication
let product = 4 * 30;

// division
let quotient = 56.7 / 32.2;

// reste
let remainder = 43 % 5;
```
### Fonctions 

> üí°Note : Rust peut acc√©der √† vos fonctions quel que soit l'endroit de leur d√©claration.

#### exemples

Vous **devez** declarer le type de valeur retourn√©e avec une fl√®che. Si vous ne le faites pas, Rust consid√©rera que votre fonction retourne par d√©faut un *tuple* vide "()".

```rust
fn get_x() -> i32 {
    76
}
```

> ‚ö†Ô∏è Bien noter qu'il n'y a **PAS** de point-virgule √† la fin; ce qui permet √† 76 d'√™tre √©valu√© comme une expression, et Rust retourne automatiquement la valeur d'une expression.

La notation ci-dessus est donc strictement √©quivalente √† la suivante :

 ```rust
 fn get_x() -> i32 {
    return 76;
}
 ```

Exemple avec des param√®tres. La signature de la fonction **doit** d√©clarer le type de chaque argument.

```rust
fn multiply(x: i32, y: i32) -> i32 {
    x * y
}
```

Exemple sans retourner explicitement une valeur ( Rust retournera donc "()" par d√©fault )

```rust
fn my_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
}
```

#### Pi√®ges pour les d√©butants

üö® Ceci provoquera une erreur du compilateur
```rust
fn multiply(x: i32, y: i32) -> i32 {
    x * y;
}
```

Comme il y a un point-virgule √† la fin de "x * y", l'expression est convertie en **d√©claration** (statement), et une d√©claration ne retourne rien. Donc Rust consid√®re que la fonction renvoie un tuple vide, ce qui ne correspondant pas au type de retour *i32* qui a √©t√© d√©clar√© dans la signature de notre fonction.

Pour r√©parer l'erreur, il suffit de retirer le point-virgule pour convertir la d√©claration en expression, dont la valeur sera retourn√©e automatiquement.

```rust
fn multiply(x: i32, y: i32) -> i32 {
    x * y
}
```

#### La diff√©rente entre arguments et param√®tres

> ‚ö†Ô∏è Les **param√®tres** sont les variables sp√©ciales utilis√©es dans la signature d'une fonction. Les **arguments** sont les valeurs concr√®tes pass√©es au moment de l'appel de la fonction.

```rust
// x est un param√®tre
fn hello_world(x: i32) {
    println!("Hello world");
}

fn main() {
  // 67 est un argument
  hello_world(67)
}
```

#### La diff√©rente entre les expressions et les d√©clarations

> ‚ö†Ô∏è Rust est un language bas√© sur les expressions, il est important de bien comprendre cette distinction.

Le corps des fonctions est compos√© d'une s√©rie de **d√©clarations** , qui se termine **√©ventuellement** par une **expression**.

Function bodies are made up of a series of **statements** *optionally* ending in an **expression**

- les **d√©clarations** ne retourne **pas** de valeur
- Les expressions sont toujours **r√©solues en une valeur** qu'elles retournent.

Exemples de d√©clarations:

```rust
// cr√©er une variable et lui assigner une valeur
let y = 5;
```
> üí° *let y = 5* est une **d√©claration** mais "5" est une **expression** qui est √©valu√© √† "5". 

Exemples d'expressions :

```rust
// Les nombres en eux-m√™me sont des expressions.
5

// les op√©ration math√©matiques
5 + 6 

// appeler une fonction
say_hello()

// appeler une macro
println! 

// les blocs ( ici √©valu√© √† 4 )
let y = {
    let x = 3;
    x + 1 
};
``` 

### Contr√¥le de flux

#### les expressions if

> üí° Note : on parlera un peu plus loin des **patterns** qui sont une autre mani√®re tr√®s puissante de g√©rer les conditions en Rust : https://doc.rust-lang.org/book/second-edition/ch18-03-pattern-syntax.html


```rust
fn main() {
    let number = 3;
    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
> ‚ö†Ô∏è Rust n'essaiera **PAS** de convertir automatiquement des types non-bool√©ens en type bool√©en au sein des conditions. 

Conditions multiples :

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

>  üí° Comme **if** est une expression, il retourne une valeur : on peut donc utiliser **if** pour assigner une valeur √† une variable :

```rust
fn main() {
    let condition = true;
    let result = if condition { 5 } else { 6 };
    println!("{}", result); // display "5"
}

```

> üö® Le code ci-dessous provoquer une erreur : chaque **bras** du **if** doit √™tre du m√™me type.

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { "six" };
    println!("The value of number is: {}", number);
}
```

#### boucles

##### loop

Le mot clef **loop** cr√©e une boucle infinie. Il faut utiliser le mot-clef **break** pour sortir d'une boucle infinie.

```rust
fn main() {
    let max = 5;
    let mut i = 0;
    loop {
        i = i + 1;
        if i > max {
            break;
        }
        println!("loop {}", i);
    }
}
```

##### while

```rust
fn main() {
    let max = 5;
    let mut i = 0;
    while i < max {
        i = i + 1;
        println!("loop {}", i);
    }
}
```

##### for

> üí°For est l'une des constructions de boucles les plus utilis√©es en Rust pour sa concision.

It√©rer sur un *array*

```rust
fn main() {
    let loops = [1, 2, 3, 4, 5];
    for element in loops.iter() {
        println!("loop {}", element);
    }
}
```
En utilisant **Range**

```rust
fn main() {
    for element in 1..6 {
        println!("loop {}", element);
    }
}
```

## Ownership

> Ownership is **all about the heap**, so this chapter **requires** some basic knowledges about what are the **stack** and the **heap**. See [Annexe: the stack and the heap](annex-stack-and-heap.md)

Rust‚Äôs central and most unique feature is **ownership**. It enables Rust to make memory safety guarantees without needing a garbage collector and without the need for the programmer to explicitly allocate and free the memory from the heap.

**Managing heap data is why Rust ownership exists** : keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don‚Äôt run out of space are all problems that ownership addresses.

> üôÇ Because ownership is a new concept for many programmers, it does take some time to get used to.

### Understand if a value is in the stack or in the heap

Ownership concern only variables whose values are stored in the "heap". 
You must be able to distinguish if a variable is stored only in the stack; or if its value is stored on the heap; because this it what will determine copy behavior and ownership.

#### Simple types

For example : Integers are a simple type, only stored in the stack; because we know at compile time their size. So this code works exactly as expected.

```rust
fn main() {
    let x = 5;
    let y = x;
    println!("{}", y);
}
```

When assigning x to y, a full copy is made and the stack will looks like :

```
y = 5
x = 5
```

#### Complex types

This is how to declare a growable and mutable piece of text.
```rust
let mut s = String::from("hello");
```

 As this is growable, Rust will not store "hello" value on the stack. String data are actually shared between two memory locations : 
- metadata are stored in the *stack* : name, length ... Those values have a known size at compile time.
- actual value is store on the heap, because it is growable and can not be known for sure at compile time

<img src="https://doc.rust-lang.org/book/second-edition/img/trpl04-01.svg" width="400px" />

#### The "Copy" trait

Rust has a special annotation called the **Copy trait** that is sued by **types** like integers that are stored **only in the stack**.  You don't have to think about ownership if the type has the Copy trait, because in this case, value is not in the heap.

**So what types are Copy?**
- All the integer types, such as u32.
- The Boolean type, bool, with values true and false.
- All the floating point types, such as f64.
- The character type, char.
- Tuples, but only if they contain types that are also Copy. For example, (i32, i32) is Copy, but (i32, String) is not.

### How Rust ownership is handling allocation in the heap

### Ownsership rules
- Each **value** in Rust has a **variable** that‚Äôs called its **owner**.
- There can only be **one** owner at a time.
- When the owner goes **out of scope**, the value will be **dropped**

Let's explore en example with String type :

```rust
{
    // "s" is valid from this point forward and is the "owner" of "Hello" value stored in the heap.
    let s = String::from("hello"); 
    
    // do stuff with "s"
    
} // this scope is now over, and "s is no longer valid : Rust drop the value automatically here.
```

A scope is the range within a program for which an item is valid. Scope in Rust is delimited by curly brackets. "String::from("hello")" is requesting an allocation in the heap. Rust calls a special **drop** functon automatically at the closing curly bracket. This is when Rust drop the "hello" value from the heap and give back the memory to the OS. 

### Move

üö®But this code will throw an error : 

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    // Rust compiler do not allow us to call s1 here, because we have assigned s1 value to s2 !
    println!("{}", s1)
}
```
This will display this error : **use of moved value s1**

```sh
error[E0382]: use of moved value: `s1`
  --> src/main.rs:14:20
   |
13 |     let s2 = s1;
   |         -- value moved here
14 |     println!("{}", s1)
   |                    ^^ value used here after move
```

That's because when we do "let s2 = s1", Rust copy **only** the stack data, not the value from the heap ! so "s2" and "s1" have actually a pointer toward the same value. 

<img src="https://doc.rust-lang.org/book/second-edition/img/trpl04-02.svg" width="400px" />

s1 can **not** be used anymore after s2 declaration, because s1 and s2 would be **two owners** for the same value in the heap allocation, and Rust allow only **one owner**. 

That is exactly what ownership is all about, and that's precisely how Rust can ensures us at **compile time** that nothing wrong can happen with memory allocation during **run time**.

> üí° Note: it is still possible to copy value from the **stack** AND the **heap** using "clone"

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```




